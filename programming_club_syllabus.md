Programming club
================

Syllabus
--------

Section 0: Python and the Programmer

0. The shell - command, flags, arguments
1. Installing the interpreter
2. Invoking the interpreter
3. Choose your weapon
4. Help and the Python Doc
5. Modules
6. Why Python? Vs Perl, Java, C, or special-purpose languages

Section 1: Data types

1. Numeric types - integer, float
2. Strings and string-likes
3. Collections - ordered/unordered; indexed/hashed; linear/tabular/tree
4. Exceptions and Errors - making them by accident, raising them on purpose
5. Namespaces

Section 2: Functions

1. Functions relate input to output
2. Invoking ("calling". functions
3. Writing ("defining". your own functions
4. Why write a function?

Section 3: Scripting

1. The shell environment, revisited
2. Moving from the shell environment to the Python runtime
3. User input from the shell - sys and the sys.argv ("argument vector". list
4. Control flow - making decisions, being logical
5. Working with files - text and otherwise (the os module.

Section 4: Objects

1. You've been using objects this whole time
2. Objects represent complex data
3. Objects encapsulate state and function
4. Classes define objects; objects "instantiate" a class
5. Defining a class; creating an object
6. Why use objects?

Section 5: Object-Oriented Design Patterns

1. What is a design pattern?
2. Maintainability and readability - why use design patterns
3. Inheritance, subclassing
4. Interfaces vs. Inheritance
5. The Singleton
6. Hiding things from yourself
7. "Fall-through" vs event-driven

Section 6: Living with Python

1. Stupid Python Tricks (object poking.
2. Handy modules from the standard library
3. Getting new modules
4. Writing your own modules
5. Version control systems

Section 7: Bad Programming

1. Anti-Patterns
2. Pattern-itis
3. Code comments and self-documentation
4. Readability
5. Re-inventing the wheel

Section 8: Moving on

1. Dynamically typed vs. statically typed languages (perl vs. Java, C.
2. Values, references, indirection
3. Imperative vs Declarative languages - SQL
4. Collections types by many names
5. Playing well with others